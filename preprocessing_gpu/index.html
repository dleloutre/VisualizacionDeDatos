<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>WebGPU Life</title>
  </head>
  <body>
    <canvas width="512" height="512"></canvas>
    <script type="module">
      // Dispatch
      function dispatchComputeShaders(device, computeShaderCode, buffers, numNodes, numEdges) {
        // Pipeline setup
        // Define bind group layouts
        const bindGroupLayout = device.createBindGroupLayout({
          entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' }},
            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
            { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
          ],
        });
        // Create pipeline layout
        const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
        const computeShaderModule = device.createShaderModule({ code: computeShaderCode });
        const computePipeline = device.createComputePipeline({
          layout: pipelineLayout,
          compute: {
              module: computeShaderModule,
              entryPoint: 'main',
          },
        });
        const encoder = device.createCommandEncoder();
        const pass = encoder.beginComputePass();
        pass.setPipeline(computePipeline);
        // GPUBindGroup defines a set of resources to be bound together in a group and how those resources are used in shader stages
        const bindGroup = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: [
              { binding: 0, resource: { buffer: buffers.nodesBuffer } },
              { binding: 1, resource: { buffer: buffers.edgesBuffer } },
              { binding: 2, resource: { buffer: buffers.newEdgesBuffer } },
              { binding: 3, resource: { buffer: buffers.uniformBuffer } }
          ],
        });
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(numNodes); // Dispatch one thread per node
        pass.end();
        encoder.copyBufferToBuffer(buffers.newEdgesBuffer, 0, buffers.resultBuffer, 0, numEdges * 4);
        device.queue.submit([encoder.finish()]);
      }
        
      async function readResults(device, resultBuffer) {
        // Once the command encoder has finished executing, you can map the result buffer to read the data
        await device.queue.onSubmittedWorkDone();
        await resultBuffer.mapAsync(GPUMapMode.READ);
        const arrayBuffer = resultBuffer.getMappedRange();
        const result = new Uint32Array(arrayBuffer);
        console.log("Result:",result);
        resultBuffer.unmap();
      }

      function createBuffers(device, nodes, edges) {
        const numNodes = nodes.length;
        const numEdges = edges.length;
        // Buffer represents a block of memory that can be used to store raw data to use in GPU operations
        const nodesBuffer = device.createBuffer({
          size: numNodes * 4, // in bytes
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
          mappedAtCreation: true
        })

        const edgesBuffer = device.createBuffer({
          size: numEdges * 4,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
          mappedAtCreation: true
        })

        const newEdgesBuffer = device.createBuffer({
          size: numEdges * 4,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
          mappedAtCreation: true
        })

        const resultBuffer = device.createBuffer({
          size: numEdges * 4,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
        });

        const uniformBuffer = device.createBuffer({
          size: 8, // 2 * sizeof(u32)
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
          mappedAtCreation: true
        });
        // returns an ArrayBuffer containing the mapped contents of the GPUBuffer in the specified range
        // sets nodes to new ArrayBuffer (an array of 32-bit floating point numbers)
        new Uint32Array(edgesBuffer.getMappedRange()).set(edges);
        new Uint32Array(newEdgesBuffer.getMappedRange()).set(edges);
        new Uint32Array(nodesBuffer.getMappedRange()).set(nodes);

        edgesBuffer.unmap();
        newEdgesBuffer.unmap();
        nodesBuffer.unmap();

        const numsArray = new Uint32Array(uniformBuffer.getMappedRange());
        numsArray[0] = numNodes;
        numsArray[1] = numEdges;
        uniformBuffer.unmap();

        const buffers = {
          nodesBuffer,
          edgesBuffer,
          newEdgesBuffer,
          uniformBuffer,
          resultBuffer
        }

        return buffers;
      }

      async function main() {
        const canvas = document.querySelector("canvas");
        // Initialize WebGPU
        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }

        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }
        const device = await adapter.requestDevice();
        const context = canvas.getContext("webgpu");

        // The getPreferredCanvasFormat() method of the GPU interface returns the optimal canvas texture format 
        // for displaying 8-bit depth, standard dynamic range content on the current system.
        const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device: device,
          format: canvasFormat,
        });

        // Data Preparation
        const nodes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] // [id1, id2, id3] 
        const edges = [1, 3, 1, 5, 1, 9, 1, 10] // [src1, dst1, dst2, dst2]
        const numNodes = nodes.length;
        const numEdges = edges.length;

        // Shader
        const computeShaderCode = `
        struct Node {
              id : u32,
              reduced : u32 // Use u32 to represent boolean values (0 for false, 1 for true)
          };

          struct Edge {
              src : u32,
              dst : u32
          };

          struct Uniforms {
              numNodes: u32,
              numEdges: u32
          };

          @group(0) @binding(0) var<storage, read_write> nodesBuffer : array<u32>;
          @group(0) @binding(1) var<storage, read_write> edgesBuffer : array<u32>;
          @group(0) @binding(2) var<storage, read_write> newEdgesBuffer : array<u32>;
          @group(0) @binding(3) var<uniform> uniforms : Uniforms;

          // Define a maximum size for neighborIds
          const MAX_NEIGHBORS: u32 = 50000;

          @compute @workgroup_size(1, 1, 1)
          fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
              let nodePosition : u32 = global_id.x;
              let nodeId : u32 = nodesBuffer[nodePosition];


              
              // Update newEdgesBuffer
              newEdgesBuffer[nodePosition] = nodeId;          // Assuming nodeId is the source
              // newEdgesBuffer[nodePosition + 1] = nodeId + 1;  // Assuming nodeId + 1 is the destination
          }
        `;
        const buffers = createBuffers(device, nodes, edges);
        dispatchComputeShaders(device, computeShaderCode, buffers, numNodes, numEdges);
        await readResults(device, buffers.resultBuffer);
      }

      main();

    </script>
  </body>
</html>