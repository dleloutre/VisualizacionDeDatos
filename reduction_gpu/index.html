<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>WebGPU Life</title>
  </head>
  <body>
    <canvas width="512" height="512"></canvas>
    <script type="module">
      // Dispatch
      function dispatchComputeShaders(device, computeShaderCode, buffers, numNodes, numEdges) {
        // Pipeline setup
        // Define bind group layouts
        const bindGroupLayout = device.createBindGroupLayout({
          entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' }},
            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },
            { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },
            { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } }
          ],
        });
        // Create pipeline layout
        const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
        const computeShaderModule = device.createShaderModule({ code: computeShaderCode });
        const computePipeline = device.createComputePipeline({
          layout: pipelineLayout,
          compute: {
              module: computeShaderModule,
              entryPoint: 'main',
          },
        });
        const encoder = device.createCommandEncoder();
        const pass = encoder.beginComputePass();
        pass.setPipeline(computePipeline);
        // GPUBindGroup defines a set of resources to be bound together in a group and how those resources are used in shader stages
        const bindGroup = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: [
              { binding: 0, resource: { buffer: buffers.nodesBuffer } },
              { binding: 1, resource: { buffer: buffers.edgesBuffer } },
              { binding: 2, resource: { buffer: buffers.newEdgesBuffer } },
              { binding: 3, resource: { buffer: buffers.uniformBuffer } },
              { binding: 4, resource: { buffer: buffers.edgesStartIndicesBuffer } }
          ],
        });
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(numNodes); // Dispatch one thread per node
        pass.end();
        encoder.copyBufferToBuffer(buffers.newEdgesBuffer, 0, buffers.resultBuffer, 0, numEdges * 4);
        device.queue.submit([encoder.finish()]);
      }
        
      async function readResults(device, resultBuffer) {
        // Once the command encoder has finished executing, you can map the result buffer to read the data
        await device.queue.onSubmittedWorkDone();
        await resultBuffer.mapAsync(GPUMapMode.READ);
        const arrayBuffer = resultBuffer.getMappedRange();
        const result = new Uint32Array(arrayBuffer);
        console.log("Result:",result);
        resultBuffer.unmap();
        return result;
      }

      function createBuffers(device, nodes, edges) {
        edges.sort((a, b) => a.src - b.src);
        // optimizar
        const edgesProcessed = edges.map((edge, index) => ({
          src: edge.src,
          dst: nodes.findIndex((value, idx) => edge.dst == value)
        }));
        const edgesStartIndices = nodes.map((node, index) => {
          const start = edges.findIndex((value, idx) => value.src == node)
          const count = edges.reduce((acc, value, idx) => acc + (value.src == node ? 1 : 0), 0)
          return [start, count]
        }).flat();
        console.log("indices", edgesStartIndices)
        console.log("edges", edgesProcessed)
        const newEdges = Array(edges.length).fill({src: -1, dst: -1})
        const numNodes = nodes.length;
        const numEdges = edges.length;
        // Buffer represents a block of memory that can be used to store raw data to use in GPU operations
        const nodesBuffer = device.createBuffer({
          size: numNodes * 4, // in bytes
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
          mappedAtCreation: true
        })

        const edgesBuffer = device.createBuffer({
          size: numEdges * 4 * 4,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
          mappedAtCreation: true
        })

        const newEdgesBuffer = device.createBuffer({
          size: numEdges * 4 * 4,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
          mappedAtCreation: true
        })

        const resultBuffer = device.createBuffer({
          size: numEdges * 4 * 4,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
        });

        const uniformBuffer = device.createBuffer({
          size: 8, // 2 * sizeof(u32)
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
          mappedAtCreation: true
        });

        const edgesStartIndicesBuffer = device.createBuffer({
          size: edgesStartIndices.length * 4 * 2, // in bytes
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
          mappedAtCreation: true
        })
        // returns an ArrayBuffer containing the mapped contents of the GPUBuffer in the specified range
        // sets nodes to new ArrayBuffer (an array of 32-bit floating point numbers)
        new Uint32Array(edgesBuffer.getMappedRange()).set(edgesProcessed);
        new Uint32Array(newEdgesBuffer.getMappedRange()).set(edgesProcessed);
        new Uint32Array(nodesBuffer.getMappedRange()).set(nodes);
        new Uint32Array(edgesStartIndicesBuffer.getMappedRange()).set(edgesStartIndices);

        edgesBuffer.unmap();
        newEdgesBuffer.unmap();
        nodesBuffer.unmap();
        edgesStartIndicesBuffer.unmap();

        const numsArray = new Uint32Array(uniformBuffer.getMappedRange());
        numsArray[0] = numNodes;
        numsArray[1] = numEdges;
        uniformBuffer.unmap();

        const buffers = {
          nodesBuffer,
          edgesBuffer,
          newEdgesBuffer,
          uniformBuffer,
          resultBuffer,
          edgesStartIndicesBuffer
        }

        return buffers;
      }

      async function main() {
        const canvas = document.querySelector("canvas");
        // Initialize WebGPU
        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }

        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }
        const device = await adapter.requestDevice();
        const context = canvas.getContext("webgpu");

        // The getPreferredCanvasFormat() method of the GPU interface returns the optimal canvas texture format 
        // for displaying 8-bit depth, standard dynamic range content on the current system.
        const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device: device,
          format: canvasFormat,
        });

        // Data Preparation
        const nodes = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] // [id1, id2, id3] 
        // const edges = [1, 3, 1, 5, 1, 9, 1, 10] // [src1, dst1, dst2, dst2]
        const edges = [
          {
            src: 1,
            dst: 3
          },
          {
            src: 2,
            dst: 5
          },
          {
            src: 1,
            dst: 4
          },
          {
            src: 4,
            dst: 5
          }
        ]
        let numNodes = nodes.length;
        let numEdges = edges.length;
        
        // Shader
        const computeShaderCode = `
          struct Node {
            id : u32,
            reduced : u32 // Use u32 to represent boolean values (0 for false, 1 for true)
          };

          struct Edge {
            src : u32,
            dst : u32
          };

          struct Uniforms {
            numNodes: u32,
            numEdges: u32
          };

          @group(0) @binding(0) var<storage, read_write> nodesBuffer : array<u32>;
          @group(0) @binding(1) var<storage, read_write> edgesBuffer : array<Edge>;
          @group(0) @binding(2) var<storage, read_write> newEdgesBuffer : array<Edge>;
          @group(0) @binding(3) var<uniform> uniforms : Uniforms;
          @group(0) @binding(4) var<storage, read_write> edgesStartIndicesBuffer : array<u32>;

          @compute @workgroup_size(1, 1, 1)
          fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
            let nodePosition : u32 = global_id.x;
            let nodeId : u32 = nodesBuffer[nodePosition];
            let start: u32 = edgesStartIndicesBuffer[nodePosition * 2u];
            let count: u32 = edgesStartIndicesBuffer[nodePosition * 2u + 1u];

            if (count == 0u) {
              return;
            }
            
            for (var i: u32 = start; i < start + count; i = i + 1u) {
              let dstPosition : u32 = edgesBuffer[i].dst;
              let dstStart : u32 = edgesStartIndicesBuffer[dstPosition * 2u];
              let dstCount : u32 = edgesStartIndicesBuffer[dstPosition * 2u + 1u];

              if (dstCount != 0u) {
                for (var j: u32 = dstStart; j < dstStart + dstCount; j = j + 1u) {
                  let newDstPosition : u32 = edgesBuffer[j].dst;
                  newEdgesBuffer[j] = Edge(nodeId, nodesBuffer[newDstPosition]);
                }
              }
            }
          }
        `;

        //while (numEdges > 3) {
          const buffers = createBuffers(device, nodes, edges);
          dispatchComputeShaders(device, computeShaderCode, buffers, numNodes, numEdges);
          const result = await readResults(device, buffers.resultBuffer);
          numEdges = result.length;
        //}
      }

      main();

    </script>
  </body>
</html>